## RUN <- TRUE


## if(RUN) {
##     gridxs <- seq(from = -1, to = 1, length.out = 128)

##     cove <- outer(gridxs, gridxs, function(x,y) sin(x) + cos(y) - 1)

##     treate <- cove
##     treate[] <- rbinom(length(c(cove)), size = 1, plogis(1.1 * cove - 0.1))

##     intense <- exp(4 + cove + treate)
##     w <- owin(xrange = c(-1, 1), yrange = c(-1, 1))
##     intens <- as.im(intense, w)
##     treatment <- as.im(treate, w)
##     cov <- as.im(cove, w)
##     outcome <- rpoispp(intens)

##     ## gride <- expand_grid(x = gridxs, y = gridxs) |> mutate( treat = c(treate))
##     Q <- quadscheme(outcome)

##     treatim <- as.im(treate, outcome$window)

##     ## indexing issue here needs corrected
##     gride <- as_tibble(coords(Q)) |> mutate(xind = floor((x - treatim$xrange[1])/treatim$xstep),
##                                             yind = floor((y - treatim$yrange[1])/treatim$ystep),
##                                             xind = if_else(xind == 0, 1, xind),
##                                             yind = if_else(yind == 0, 1, yind),
##                                             treat = treatim$v[cbind(xind, yind)],
##                                             )
##     om <- ppm(outcome ~ s(x,y) + treatment, use.gam = TRUE)
##     data <- getglmdata(om)
##     om <- getglmfit(om)
##     em <- gam(treat ~ s(x,y), data = gride, family = binomial())

## }
#' @export
replace_values <- function(im, value) {
    im[] <- c(value)
    return(im)
}

#' @export
ATE <- function(outcome_model, exposure_model, data, method = c('AIPW', 'TMLE', 'IPW', 'Entropy', 'Outcome', 'Energy')){

    ## TODO move propensity score logic to here 

    ## pixellate takes a point process valued response variable as input.
    ## the efficient influence function involves an integral over the empirical counting process
    ## generated by the observed response: i.e. a sum over the points
    ## one possible way to handle this is to include it an the integral, but with a delta function representationa
    ## For a pixelated delta function, the delta function is approximated by a flat function of the proper height to integrate to 1
    ## This function handles this logic in the regular grid case.

    ## Alternative quadrature schemes should be explored including an irregular mesh quadrature (triangular approximation to delta functions
    ## Or alternatively, direct summation over the observed points, acknowledging that this is a measure zero set and does not affect the integral otherwise.

    response <- pixellate(response, DivideByPixelArea = TRUE)

    if (method == 'AIPW'){
        data |> mutate(
                    mu1 <- predict(outcome_model, newdata = mutate(data, treatment = 1), type = 'response'),
                    mu0 <- predict(outcome_model, newdata = mutate(data, treatment = 0), type = 'response')
        ## needs to be able to take new data
                    ## pi <- predict(exposure_model, newdata =   type = 'response'))
)

 
        ## approximate delta functionintegration version
        ## treated <- integral(mu1 + treatment * (response - mu1) / pi)
        ## untreated <- integral(mu0 + (1 - treatment) * (response - mu0) / (1 - pi))

        ## direct summation version
        ## evaluate at exact coordinates and sum inverse propensity weighted points
        ## evaluate the integral of inverse probability weighted treatment indicator seperately.
        
        return(treated - untreated)
    }
}

#' @export
ATT <- function(){
    
}

#' @export
ATU <- function(){}


#' @export
DoseR <- function(outcome_model, exposure_model, response, prediction_data, treatment_variable, method = 'AIPW'){
    response <- pixellate(response, DivideByPixelArea = TRUE)
    if (method == 'AIPW'){

        treatment_variable <- as.character(ensym(treatment_variable))
        treatment <- prediction_data[[treatment_variable]]

        sample_points <- as.ppp(quadscheme(response))
        spcoord <- coords(sample_points)
        pseudoreg <- as_tibble(spcoord) |>
            mutate(treat = treatment[sample_points],
                   pi = predict(exposure_model, newdata = spcoord, type = 'response'),
                   outcome = renormalize_response(outcome)[sample_points],
                   mu = predict(outcome_model, locations = sample_points))
        ## generate pseudooutcome_components
        Elambda <- rep(0, nrow(pseudoreg))
        Epi <- rep(0, nrow(pseudoreg))
        
        outreg <- getglmfit(outcome_model)
        lambda_terms <- predict(outreg, newdata = pseudoreg, type = 'terms')

        xterms <- lambda_terms[,1] + attr(lambda_terms, 'constant')
        treatment_term <- lambda_terms[,2]

        ## need to assess propensity score at each treatment and average to get normalizing constant
        piterms <- predict(exposure_model, newdata = spcoord, type = 'terms')
        
        for (i in 1:nrow(pseudoreg)){

            Elambda[i] <- mean( exp(xterms + treatment_term[i]))

            ## pil <- propensity_score(treatment, nd)
            treat[i] 
            
        }

        pseudoreg <- mutate(pseudoreg, po = Elambda + Epi * (outcome - mu) / pi)


        ## sample code for tmle

        ## only for binary case
        Epi <- mean(treat)
        pseudoreg <- mutate(pseudoreg, clever = Epi / pi * (outcome -mu))

        tm_fit <- glm(outcome ~ offset(mu) + clever - 1, data = pseudoreg, family = poisson())
        p <- predict(tm_fit)
        tmpo <- p

        glm(tmpo ~ treat, data = pseudoreg)

        X <- cbind(1, pseudoreg$treat)
        estfun <- function(par) t(X) %*% (pseudoreg$outcome - exp(X %*% par))
        to_optim <-function(par) sum(estfun(par)^2)


        ## influence function is doubly robust estimator
        ## of potential outcome intensity, a pseudointensity.
        
    }
}


#' @export
DoseR_continuous <- function(){

}
